import os
import threading
import sqlite3

class ConcurrentDatabase:
    _instance = None
    _lock = threading.Lock()

    _connection: sqlite3.Connection = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            with cls._lock:
                # another thread could have created the instance
                # before we acquired the lock. So check that the
                # instance is still nonexistent.
                if not cls._instance:
                    cls._instance = super(ConcurrentDatabase, cls).__new__(cls)
        return cls._instance

    def init_connection(self, db_path) -> None:
        with self._lock:
            db_path = os.path.abspath(os.path.realpath(os.path.expanduser(db_path)))
            _connection = sqlite3.connect(db_path, check_same_thread=False)
        return
    
    def _init_sql(self) -> None:
        _cursor = self.get_cursor()
        _cursor.execute("""
            CREATE TABLE IF NOT EXISTS device_record (
                id      int NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT,
                host    varchar(32) NOT NULL,
                name    varchar(128) NULL,
                device  int NULL
            );

            CREATE TABLE IF NOT EXISTS device_phone_list (
                device_list_id int NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT,
            )

            CREATE TABLE IF NOT EXISTS device_email_list (
                device_list_id int NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT,
            )

            CREATE TABLE IF NOT EXISTS device (
                id int NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT
            )
        """)

    def get_cursor(self) -> sqlite3.Cursor:
        # Allow maximum one cursor at a time to be active.
        # The lock is acquired in the get_cursor method and released again upon committing.
        self._lock.acquire()
        return self._connection.cursor()

    def commit(self) -> None:
        self._lock.release()
        return self._connection.commit()

class AirDropData:

    @staticmethod
    def save_find_result():
        pass

    @staticmethod
    def save_crack_result():
        pass